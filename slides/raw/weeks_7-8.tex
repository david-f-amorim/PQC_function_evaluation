\documentclass{beamer}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage[UKenglish]{babel}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{braket}
\usepackage{esint}
\usepackage{float}
\usepackage{tabularx}
\usepackage{array}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{colorlinks=false, bookmarks=true}
\usepackage{tikz}
\usetikzlibrary{quantikz2}
\usepackage{adjustbox}



\usetheme{Madrid}
\usecolortheme{seahorse}
\usefonttheme{professionalfonts}
\useinnertheme{circles}

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}

\setbeamertemplate{caption}[numbered]

\title[QCNN State Preparation]{A QCNN for Quantum State Preparation}
\subtitle{Carnegie Vacation Scholarship}
\author[David Amorim]{David Amorim}
\institute[]{}
\date[21/08/2024]{Weeks 7-8 \\(12/08/2024 - 23/08/2024)}

\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Aims for the Week}
The following aims were set at the last meeting (14/08/2024):

\begin{alertblock}{New Phase Encoding Approach}
Investigate a new approach to phase encoding using linear piecewise phase functions without explicit function evaluation.  
\end{alertblock}

\begin{alertblock}{Handover}
Hand over the slides, documentation, code and the poster for the Carnegie Trust.
\end{alertblock}
\end{frame}

\section{Phase Encoding}

\begin{frame}
\frametitle{Preliminaries}

\begin{itemize}
\item Consider an \alert{$n$-qubit} register with computational basis states $\ket{j} = \ket{j_0 j_1 ... j_{n-1}}$ representing $n$-bit strings
\item Let \alert{$p$} of the register qubits be \alert{precision qubits} so that 
\begin{equation}
j = \sum^{n -1}_{k=0} j_k 2^{k-p}
\end{equation} 
\item Consider a \alert{phase function} $\Psi$ over the domain $\Omega = \{ j \}$ and construct an \alert{$M$-fold partition} ($M = 2^m$, $m \leq n \in \mathbb{N}$) into equal sub-domains $\Omega_u$:
\begin{equation}
\Omega = \bigcup_{u=1}^M \Omega_u, \; \; \; \Omega_u \cap \Omega_v = \emptyset, \;  \; \; |\Omega_u| = |\Omega_v|
\end{equation}
\item On each sub-domain, approximate $\Psi$ using a \alert{linear function}:
\begin{equation}
\Psi(j) = \alpha_u j + \beta_u, \; \; \; j \in \Omega_u
\end{equation}
\end{itemize}

\end{frame}

\begin{frame}

\frametitle{Phase Encoding within a Sub-domain}

\begin{block}{Aim 1}
For $j \in \Omega_u$ construct an \alert{operator $\hat{O}_u$} such that $\ket{j} \mapsto e^{i (\alpha_u j + \beta_u )} \ket{j}$. 
\end{block}

\begin{itemize}
\item Consider the single-qubit operators 
\begin{equation}
\hat{P}^{(k)}(\varphi) = \begin{pmatrix}
e^{i \varphi} & 0 \\ 0 & e^{i \varphi}
\end{pmatrix}, \; \; \; \hat{R}^{(k)}(\varphi) = \begin{pmatrix}
1 & 0 \\ 0 & e^{i \varphi}
\end{pmatrix}
\end{equation}
each acting on the $k$th qubit
\item Then \alert{
\begin{equation}
\hat{O}_u \equiv \bigotimes^{n-1}_{k=0} \hat{P}^{(k)} (\beta_u / n) \hat{R}^{(k)} \left( \alpha_u 2^{k-p} \right)
\end{equation}}
transforms 
\begin{equation}
\ket{j} \mapsto \exp \left[ i \left( \sum_{k=0}^{n-1} \alpha_u j_k 2^{k-p} + \beta_u \right) \right] \ket{j} = e^{i (\alpha_u j + \beta_u )} \ket{j}
\end{equation}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Selecting the Subdomain}
\begin{itemize}
\item It is straight-forward to construct $\hat{O}_u$ for each of the sub-domains $\Omega_u$ 
\item More challenging is \alert{applying the correct $\hat{O}_u$} based on the sub-domain corresponding to each $\ket{j}$
\end{itemize}
\begin{block}{Aim 2}
Construct a \alert{system of controls} such that $\hat{O}_u$ is applied to $\ket{j}$ if and only if $j \in \Omega_u$
\end{block}
\end{frame}

\begin{frame}
\frametitle{Sample Case: $M=2$}
\begin{columns}
\begin{column}{0.4\textwidth}
\begin{itemize}
\item Start with the simplest possible case, a \alert{2-fold} partition ($M=2$): 
\begin{equation}
j \in \begin{cases}
\Omega_1 & j_0 = 0 \\
\Omega_2 & j_0 = 1
\end{cases}
\end{equation}
\item Using an \alert{ancilla qubit}, $\hat{O}_1$ is applied for $j \in \Omega_1$ and $\hat{O}_2$ for $j \in \Omega_2$
\item The ancilla is required since the operation applied to $\ket{j_0}$ is conditional on $\ket{j_0}$ itself 
\end{itemize}
\end{column}
\begin{column}{0.6\textwidth}
\begin{figure}
\centering 
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{0}_a$}& \targ{} & \ctrl{1} & \targ{} & \ctrl{1} &  \\
\lstick{$\ket{j_0}$}& \ctrl{-1} & \gate[3]{O_2} & & \gate[3]{O_1} & \rstick[3]{$\ket{j}$} \\
\lstick{\vdots}&& &&&   \\
\lstick{$\ket{j_{n-1}}$}&& &&& 
\end{quantikz}
\caption{Circuit diagram for $M=2$}
\end{figure}
\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Generalising the Approach}
\begin{columns}
\begin{column}{0.4\textwidth}
\begin{itemize}
\item The approach shown on the previous slide requires \alert{$1 \leq  \log_2 M  \leq n $ ancilla qubits}
\item The number of \alert{controls} required is \alert{$\mathcal{O}(M \log M)$} as there are $M$ operators, each controlled by all ancillas 
\item For $M \sim 2^n$ the gate cost is exponential
\end{itemize}
\end{column}
\begin{column}{0.6\textwidth}
\begin{figure}
\centering
\begin{adjustbox}{width=\textwidth}
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{0}_a$}& \targ{} && \ctrl{2} &  & \ctrl{1} & \targ{} & \ctrl{2}&  & \ctrl{2} &  \\
\lstick{$\ket{0}_a$}&& \targ{} & \ctrl{0} & \targ{} & \ctrl{1} & \targ{} & \ctrl{0} & \targ{} &\ctrl{1} &  \\
\lstick{$\ket{j_0}$}& \ctrl{-2} &   & \gate[4]{O_4} &  & \gate[4]{O_3}  && \gate[4]{O_2}& & \gate[4]{O_1} & \rstick[4]{$\ket{j}$}  \\
\lstick{$\ket{j_1}$}&& \ctrl{-2} & &  &&  && &&  \\
\lstick{\vdots}&&& &&&  && && \\
\lstick{$\ket{j_{n-1}}$}&&& &&& && &&
\end{quantikz}
\end{adjustbox}
\caption{Circuit diagram for $M=4$. Note that $j \in \Omega_u$ if $j_0j_1 =u-1$ (e.g. $j\in \Omega_3$ if $j_0 j_1 =10$).}
\end{figure}
\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{A Recursive Approach}
\begin{itemize}
\item Since $M=2^m$ for some $m \leq n \in \mathbb{N}$ we can view the partition of $\Omega$ as a recursive process, splitting the domain into halves $m$ times
\item Associate with each control qubit, $g$, two operators, $\hat{O}^{(g)}_0$ and $\hat{O}^{(g)}_1$ EACH ACTING ON THE REMAINING QUBITS! (CASCADE)
\item  Is it possible to construct 
\begin{equation}
\hat{O}_u = \prod^m_{g=1} \hat{O}^{(g)} ??
\end{equation} 
\item DEFINE THE APPROPRIATE O AND U OPERATORS !!!
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{A Recursive Approach}
\begin{figure}
\centering
\begin{adjustbox}{height=0.8\Height}
\begin{quantikz}[row sep={0.7cm,between origins}, align equals at=3.5]
\lstick{\vdots}&& &&   \\
\lstick{$\ket{j_g}$}&   &  & \ctrl{1} &  \\
\lstick{$\ket{j_{g+1}}$}&  \gate[3]{O^{(g)}_0} & & \gate[3]{O^{(g)\dagger}_0 O^{(g)}_1} &   \\
\lstick{\vdots}&& &&   \\
\lstick{$\ket{j_{n-1}}$}&& &&
\end{quantikz} $\equiv$  \begin{quantikz}[row sep={0.7cm,between origins}, align equals at=3.5]
\lstick{\vdots}& &  \\
\lstick{$\ket{j_g}$}     & \ctrl{1} &  \\
\lstick{$\ket{j_{g+1}}$}  & \gate[3]{O^{(g)}} &   \\
\lstick{\vdots}& &   \\
\lstick{$\ket{j_{n-1}}$}& &
\end{quantikz}
\end{adjustbox}
\caption{The controlled operator $\hat{O}^{(g)}$ ($0 \leq g \leq m-1$)}
\end{figure}
\begin{figure}
\centering
\begin{adjustbox}{height=0.8\Height}
\begin{quantikz}[row sep={0.7cm,between origins}, align equals at=2.5]
\lstick{$\ket{j_0}$}&  \gate[3]{U^{(g)}_0}  &  \gate[3]{U^{(g)\dagger}_0 U^{(g)}_1}  &  \\
\lstick{\vdots}&& &  \\
\lstick{$\ket{j_{g+1}}$}&  &&   \\
\lstick{$\ket{j_g}$}&     & \ctrl{-1} &  \\
\end{quantikz} $\equiv$  \begin{quantikz}[row sep={0.7cm,between origins}, align equals at=2.5]
\lstick{$\ket{j_0}$}&  \gate[3]{U^{(g)}}   &   \\
\lstick{\vdots}&&   \\
\lstick{$\ket{j_{g+1}}$}&  &    \\
\lstick{$\ket{j_g}$}& \ctrl{-1}    &  \\
\end{quantikz}
\end{adjustbox}
\caption{The controlled operator $\hat{U}^{(g)}$ ($1 \leq g \leq m-1$)}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{A Recursive Approach}
\begin{figure}
\centering
\begin{adjustbox}{width=\textwidth}
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{j_0}$} & \ctrl{1} & &  \ \ldots\ & & \gate[3]{U^{(m-1)}} &  \ \ldots\   & \gate[1]{U^{(1)}} & \gate{U^{(0)}} &   \rstick[4]{controls}  \\
\lstick{$\ket{j_1}$}&  \gate[7]{O^{(0)}}  &   \ctrl{1} &  \ \ldots\ && &  \ \ldots\ & \ctrl{-1} & & \\
\lstick{$\vdots$} & &   \gate[6]{O^{(1)}}&  \ \ldots\ & & &  \ \ldots\ & & &  \\
\lstick{$\ket{j_{m-1}}$} & & &  \ \ldots\ &   \ctrl{1} & \ctrl{-1}  &  \ \ldots\ &  & & \\
\lstick{$\ket{j_{m}}$} & & & \ \ldots\ & \gate[4]{O^{(m-1)}} \slice{} &  & \ \ldots\ & & & \rstick[4]{targets} \\
\lstick{$\ket{j_{m+1}}$}& & &  \ \ldots &  & &  \ \ldots\ & & & \\
\lstick{\vdots}& & &  \ \ldots\ &  &  & \ \ldots\  & & & \\
\lstick{$\ket{j_{n-1}}$}& & &  \ \ldots\ & & &  \ \ldots\ & & &
\end{quantikz}
\end{adjustbox}
\caption{Cascaded controls: $2m-1$ controlled operations}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Comments Sarah}
For the other problem, yes this is exactly what I had in mind, this is the right idea. A couple of suggestions:
\begin{itemize}
\item I think that you can get rid of the ancillae entirely, and just condition directly on the first few (log M) qubits.
\item I agree that you should be able to simplify a bit more by thinking about applying the operators recursively.
\item Sadly it will always scale exponentially if we take $M \sim O(2^n)$. It would be helpful to consider breaking the circuit (conceptually, not literally...) into m = log M qubits (which will be the controls) and n-m remaining qubits (the targets). If m $\ll$ n, how does the complexity scale with m and n?
\item Finally, how does the complexity of applying the phase in this way compare to the previous method of calculating the phase in an ancilla register, applying the phase, and then uncomputing the result in the ancilla.
\end{itemize}

\end{frame}



\section{Handover}

\begin{frame}

\frametitle{Handover}

The code, documentation, slides, and poster are all available on GitHub:
\begin{center}
\vspace{0.6cm}
\href{https://github.com/david-f-amorim/PQC_function_evaluation}{\texttt{https://github.com/david-f-amorim/PQC\_function\_evaluation}}
\vspace{0.6cm}
\end{center}

\begin{itemize}
\item The source code is found in the directory \alert{\texttt{pqcprep}} 
\item The slides and poster are found in the directory \alert{\texttt{slides}}
\item The documentation is hosted externally  \href{https://david-f-amorim.github.io/PQC_function_evaluation/pqcprep.html}{\textcolor{purple}{here}}, which is linked on GitHub
\end{itemize}

\end{frame}

\end{document}