\documentclass{beamer}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage[UKenglish]{babel}
\usepackage{enumerate}
\usepackage{graphicx}
\usepackage{braket}
\usepackage{esint}
\usepackage{float}
\usepackage{tabularx}
\usepackage{array}
\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{xcolor}
\hypersetup{colorlinks=false, bookmarks=true}
\usepackage{tikz}
\usetikzlibrary{quantikz2}
\usepackage{adjustbox}



\usetheme{Madrid}
\usecolortheme{seahorse}
\usefonttheme{professionalfonts}
\useinnertheme{circles}

\AtBeginSection[]
{
  \begin{frame}
    \frametitle{Table of Contents}
    \tableofcontents[currentsection]
  \end{frame}
}

\setbeamertemplate{caption}[numbered]

\title[QCNN State Preparation]{A QCNN for Quantum State Preparation}
\subtitle{Carnegie Vacation Scholarship}
\author[David Amorim]{David Amorim}
\institute[]{}
\date[21/08/2024]{Weeks 7-8 \\(12/08/2024 - 23/08/2024)}

\begin{document}

\frame{\titlepage}

\begin{frame}
\frametitle{Aims for the Week}
The following aims were set at the last meeting (14/08/2024):

\begin{alertblock}{New Phase Encoding Approach}
Investigate a new approach to phase encoding using linear piecewise phase functions without explicit function evaluation.  
\end{alertblock}

\begin{alertblock}{Handover}
Hand over the slides, documentation, code and the poster for the Carnegie Trust.
\end{alertblock}
\end{frame}

\section{Phase Encoding}

\begin{frame}
\frametitle{Preliminaries}

\begin{itemize}
\item Consider an \alert{$n$-qubit} register with computational basis states $\ket{j} = \ket{j_0 j_1 ... j_{n-1}}$ representing $n$-bit strings
\item Let \alert{$p$} of the register qubits be \alert{precision qubits} so that 
\begin{equation}
j = \sum^{n -1}_{k=0} j_k 2^{k-p}
\end{equation} 
\item Consider a \alert{phase function} $\Psi$ over the domain $\mathcal{D} = \{ j \}$ and construct an \alert{$M$-fold partition} ($M = 2^m$, $m \leq n \in \mathbb{N}$) into equal sub-domains $\mathcal{D}_u$:
\begin{equation}
\mathcal{D} = \bigcup_{u=1}^M \mathcal{D}_u, \; \; \; \mathcal{D}_u \cap \mathcal{D}_v = \emptyset, \;  \; \; |\mathcal{D}_u| = |\mathcal{D}_v|
\end{equation}
\item On each sub-domain, approximate $\Psi$ using a \alert{linear function}:
\begin{equation}
\Psi(j) = \alpha_u j + \beta_u, \; \; \; j \in \mathcal{D}_u
\end{equation}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Preliminaries}
\begin{alertblock}{Aim}
Construct an appropriate operator to transform 
\begin{equation}
\ket{j} \mapsto e^{i \Psi (j)} \ket{j}
\end{equation}
via the linear piecewise approximation
\begin{equation}
\ket{j} \mapsto e^{i (\alpha_u j + \beta_u)} \ket{j} \; \; \; (j \in \mathcal{D}_u)
\end{equation}
\end{alertblock}
\end{frame}

\begin{frame}
\frametitle{General Remarks}
\begin{itemize}
\item The $2^m$ pairs of coefficients $(\alpha_u, \beta_u)$ require $2^m$ independent operators $\hat{O}_u$ to implement
\item Each operator $\hat{O}_u$ will generally involve $n$ controlled rotations 
\item The choice of $\hat{O}_u$ will generally involve all $m$ control qubits 
\item Thus, it seems like a \alert{$\sim \mathcal{O}(2^m n m)$ complexity} is to be expected for this algorithm [NO! A N-CONTROLLED OPERATION HAS A COST HIGHER THAN N!!] => READ PAPERS (BOOKMARKED!): Lemma 7.5  / Cor 7.6 Barenco ' linear approximation: Lemma 7.8 Barenco  ; linear with ancilla ?! Corollary 7.12 
\item 
\item While recursion cannot reduce the required number of independent operators it could simplify circuit structure
\end{itemize}
\end{frame}

\begin{frame}

\frametitle{Phase Encoding within a Sub-domain}

\begin{block}{Aim 1}
For $j \in \mathcal{D}_u$ construct an \alert{operator $\hat{O}_u$} such that $\ket{j} \mapsto e^{i (\alpha_u j + \beta_u )} \ket{j}$. 
\end{block}

\begin{itemize}
\item Consider the single-qubit operators 
\begin{equation}
\hat{P}^{(k)}(\varphi) = \begin{pmatrix}
e^{i \varphi} & 0 \\ 0 & e^{i \varphi}
\end{pmatrix}, \; \; \; \hat{R}^{(k)}(\varphi) = \begin{pmatrix}
1 & 0 \\ 0 & e^{i \varphi}
\end{pmatrix}
\end{equation}
each acting on the $k$th qubit
\item Then \alert{
\begin{equation}
\hat{O}_u \equiv \bigotimes^{n-1}_{k=0} \hat{P}^{(k)} (\beta_u / n) \hat{R}^{(k)} \left( \alpha_u 2^{k-p} \right)
\end{equation}}
transforms 
\begin{equation}
\ket{j} \mapsto \exp \left[ i \left( \sum_{k=0}^{n-1} \alpha_u j_k 2^{k-p} + \beta_u \right) \right] \ket{j} = e^{i (\alpha_u j + \beta_u )} \ket{j}
\end{equation}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Selecting the Subdomain}
\begin{itemize}
\item It is straight-forward to construct $\hat{O}_u$ for each of the sub-domains $\mathcal{D}_u$ 
\item More challenging is \alert{applying the correct $\hat{O}_u$} based on the sub-domain corresponding to each $\ket{j}$
\end{itemize}
\begin{block}{Aim 2}
Construct a \alert{system of controls} such that $\hat{O}_u$ is applied to $\ket{j}$ if and only if $j \in \mathcal{D}_u$
\end{block}
\end{frame}

\begin{frame}
\frametitle{Sample Case: $M=2$}
\begin{columns}
\begin{column}{0.4\textwidth}
\begin{itemize}
\item Start with the simplest possible case, a \alert{2-fold} partition ($M=2$): 
\begin{equation}
j \in \begin{cases}
\mathcal{D}_1 & j_0 = 0 \\
\mathcal{D}_2 & j_0 = 1
\end{cases}
\end{equation}
\item Using an \alert{ancilla qubit}, $\hat{O}_1$ is applied for $j \in \mathcal{D}_1$ and $\hat{O}_2$ for $j \in \mathcal{D}_2$
\item The ancilla is required since the operation applied to $\ket{j_0}$ is conditional on $\ket{j_0}$ itself 
\end{itemize}
\end{column}
\begin{column}{0.6\textwidth}
\begin{figure}
\centering 
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{0}_a$}& \targ{} & \ctrl{1} & \targ{} & \ctrl{1} &  \\
\lstick{$\ket{j_0}$}& \ctrl{-1} & \gate[3]{O_2} & & \gate[3]{O_1} & \rstick[3]{$\ket{j}$} \\
\lstick{\vdots}&& &&&   \\
\lstick{$\ket{j_{n-1}}$}&& &&& 
\end{quantikz}
\caption{Circuit diagram for $M=2$}
\end{figure}
\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{Generalising the Approach}
\begin{columns}
\begin{column}{0.4\textwidth}
\begin{itemize}
\item The approach shown on the previous slide requires \alert{$1 \leq  \log_2 M  \leq n $ ancilla qubits}
\item The number of \alert{controls} required is \alert{$\mathcal{O}(M \log M n)$} as there are $M$ operators, each controlled by all ancillas and each involving $n$ controlled rotations
\item For $M \sim 2^n$ the gate cost is exponential
\end{itemize}
\end{column}
\begin{column}{0.6\textwidth}
\begin{figure}
\centering
\begin{adjustbox}{width=\textwidth}
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{0}_a$}& \targ{} && \ctrl{2} &  & \ctrl{1} & \targ{} & \ctrl{2}&  & \ctrl{2} &  \\
\lstick{$\ket{0}_a$}&& \targ{} & \ctrl{0} & \targ{} & \ctrl{1} & \targ{} & \ctrl{0} & \targ{} &\ctrl{1} &  \\
\lstick{$\ket{j_0}$}& \ctrl{-2} &   & \gate[4]{O_4} &  & \gate[4]{O_3}  && \gate[4]{O_2}& & \gate[4]{O_1} & \rstick[4]{$\ket{j}$}  \\
\lstick{$\ket{j_1}$}&& \ctrl{-2} & &  &&  && &&  \\
\lstick{\vdots}&&& &&&  && && \\
\lstick{$\ket{j_{n-1}}$}&&& &&& && &&
\end{quantikz}
\end{adjustbox}
\caption{Circuit diagram for $M=4$. Note that $j \in \mathcal{D}_u$ if $j_0j_1 =u-1$ (e.g. $j\in \mathcal{D}_3$ if $j_0 j_1 =10$).}
\end{figure}
\end{column}
\end{columns}
\end{frame}

\begin{frame}
\frametitle{A Recursive Approach}
\begin{itemize}
\item Since $M=2^m$ for some $m \leq n \in \mathbb{N}$ we can view the partition of $\mathcal{D}$ as a recursive process, splitting the domain into halves $m$ times
\item Associate with each control qubit, $g$, two operators, $\hat{O}^{(g)}_0$ and $\hat{O}^{(g)}_1$ EACH ACTING ON THE REMAINING QUBITS! (CASCADE)
\item  Is it possible to construct 
\begin{equation}
\hat{O}_u = \prod^m_{g=1} \hat{O}^{(g)} ??
\end{equation} 
\item DEFINE THE APPROPRIATE O AND U OPERATORS !!!
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{A Recursive Approach}
\begin{figure}
\centering
\begin{adjustbox}{height=0.8\Height}
\begin{quantikz}[row sep={0.7cm,between origins}, align equals at=3.5]
\lstick{\vdots}&& &&   \\
\lstick{$\ket{j_g}$}&   &  & \ctrl{1} &  \\
\lstick{$\ket{j_{g+1}}$}&  \gate[3]{O^{(g)}_0} & & \gate[3]{O^{(g)\dagger}_0 O^{(g)}_1} &   \\
\lstick{\vdots}&& &&   \\
\lstick{$\ket{j_{n-1}}$}&& &&
\end{quantikz} $\equiv$  \begin{quantikz}[row sep={0.7cm,between origins}, align equals at=3.5]
\lstick{\vdots}& &  \\
\lstick{$\ket{j_g}$}     & \ctrl{1} &  \\
\lstick{$\ket{j_{g+1}}$}  & \gate[3]{O^{(g)}} &   \\
\lstick{\vdots}& &   \\
\lstick{$\ket{j_{n-1}}$}& &
\end{quantikz}
\end{adjustbox}
\caption{The controlled operator $\hat{O}^{(g)}$ ($0 \leq g \leq m-1$)}
\end{figure}
\begin{figure}
\centering
\begin{adjustbox}{height=0.8\Height}
\begin{quantikz}[row sep={0.7cm,between origins}, align equals at=2.5]
\lstick{$\ket{j_0}$}&  \gate[3]{U^{(g)}_0}  &  \gate[3]{U^{(g)\dagger}_0 U^{(g)}_1}  &  \\
\lstick{\vdots}&& &  \\
\lstick{$\ket{j_{g+1}}$}&  &&   \\
\lstick{$\ket{j_g}$}&     & \ctrl{-1} &  \\
\end{quantikz} $\equiv$  \begin{quantikz}[row sep={0.7cm,between origins}, align equals at=2.5]
\lstick{$\ket{j_0}$}&  \gate[3]{U^{(g)}}   &   \\
\lstick{\vdots}&&   \\
\lstick{$\ket{j_{g+1}}$}&  &    \\
\lstick{$\ket{j_g}$}& \ctrl{-1}    &  \\
\end{quantikz}
\end{adjustbox}
\caption{The controlled operator $\hat{U}^{(g)}$ ($1 \leq g \leq m-1$)}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{A Recursive Approach}
\begin{figure}
\centering
\begin{adjustbox}{width=\textwidth}
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{j_0}$} & \ctrl{1} & &  \ \ldots\ & & \gate[3]{U^{(m-1)}} &  \ \ldots\   & \gate[1]{U^{(1)}} & \gate{U^{(0)}} &   \rstick[4]{controls}  \\
\lstick{$\ket{j_1}$}&  \gate[7]{O^{(0)}}  &   \ctrl{1} &  \ \ldots\ && &  \ \ldots\ & \ctrl{-1} & & \\
\lstick{$\vdots$} & &   \gate[6]{O^{(1)}}&  \ \ldots\ & & &  \ \ldots\ & & &  \\
\lstick{$\ket{j_{m-1}}$} & & &  \ \ldots\ &   \ctrl{1} & \ctrl{-1}  &  \ \ldots\ &  & & \\
\lstick{$\ket{j_{m}}$} & & & \ \ldots\ & \gate[4]{O^{(m-1)}} \slice{} &  & \ \ldots\ & & & \rstick[4]{targets} \\
\lstick{$\ket{j_{m+1}}$}& & &  \ \ldots &  & &  \ \ldots\ & & & \\
\lstick{\vdots}& & &  \ \ldots\ &  &  & \ \ldots\  & & & \\
\lstick{$\ket{j_{n-1}}$}& & &  \ \ldots\ & & &  \ \ldots\ & & &
\end{quantikz}
\end{adjustbox}
\caption{Cascaded controls: $2m-1$ controlled operations}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{A Recursive Approach}
\begin{itemize}
\item Consider 
\begin{equation}
\hat{U}^{(k)}_u \equiv \hat{P}^{(k)} (\beta_u /n ) \hat{R}^{(k)} (\alpha_u 2^{k-p})
\end{equation}
and define 
\begin{equation}
\hat{V}^{(k)}_u =\hat{U}^{(k)}_u \prod_{q=1}^{u-1}  \hat{U}^{(k) \dagger}_q
\end{equation}
which is equivalent to a single rotation gate 
\item Use the notation from Barenco 1995 to denote a single-qubit operation $\hat{V}$ controlled by $m$ qubits $\wedge_m (\hat{V})$
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The Case $m=2$ ($M=4$)}
\begin{figure}
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{j_0}$} & & & \ctrl{1} &  & \ctrl{1} & \ctrl{2} & \rstick[2]{controls}  \\
\lstick{$\ket{j_1}$} & & \ctrl{1} & \targ{} & \ctrl{1} & \targ & & & \\
\lstick{$\ket{j_k}$} & \gate{V_0} & \gate{V_1} & & \gate{V_2} & & \gate{V_3} & \rstick{target} \\
\end{quantikz}
\caption{Control structure for $m=2$ ($M=4$) with $2 \leq k < n$. The number of controlled operations is $2^{m+1}-3=5$.}
\end{figure}

\begin{table}
\centering 
\begin{tabular}{c | c | c || c | c | c }
$(j_0 j_1)$ & Operation & Equiv. $\hat{U}$ & $(j_0 j_1)$ & Operation & Equiv. $\hat{U}$ \\ \hline 
(00) & $\hat{V}_0$ & $\hat{U}_0$ & (10) & $\hat{V}_0 \hat{V}_2 \hat{V}_3 $ & $\hat{U}_2$ \\
(01) & $\hat{V}_0 \hat{V}_1 \hat{V}_2$ & $\hat{U}_1$ & (11) & $\hat{V}_0 \hat{V}_1 \hat{V}_3$ & $\hat{U}_3$ 
\end{tabular}
\caption{Operations applied to $\ket{j_k}$ for various control states ORDER REVERSED!!}
\end{table}
\hspace{0.5cm}
\end{frame}

\begin{frame}
\frametitle{The Case $m=3$ ($M=8$)}
\begin{figure}
\begin{adjustbox}{width=\textwidth}
\begin{quantikz}[row sep={0.7cm,between origins}]
\lstick{$\ket{j_0}$} & &  \ctrl{3} & \ctrl{1} & & \ctrl{1} & & & & \ctrl{2} & & & & \ctrl{2} & &   \rstick[3]{controls} \\
\lstick{$\ket{j_1}$} &  & &\targ{} & \ctrl{2} & \targ{} & \ctrl{2}& \ctrl{1}&&&& \ctrl{1}&&  & &  \\
\lstick{$\ket{j_2}$} &  & & &&&& \targ{}& \ctrl{1}& \targ{}& \ctrl{1}& \targ{}& \ctrl{1} & \targ{} & \ctrl{1} &  \\
\lstick{$\ket{j_k}$} &  \gate{V_0} & \gate{V_1} & & \gate{V_2}& & \gate{V_3}& & \gate{V_4}& & \gate{V_5}&& \gate{V_6}&& \gate{V_7} &  \rstick[1]{target} \\
\end{quantikz}
\end{adjustbox}
\caption{Control structure for $m=3$ ($M=8$) with $3 \leq k < n$. The number of controlled operations is $2^{m+1}-3=13$.}
\end{figure}

\begin{table}
\centering 
\begin{tabular}{c | c | c || c | c | c }
$(j_0 j_1 j_2)$ & Operation & Equiv. $\hat{U}$ & $(j_0 j_1 j_2)$ & Operation & Equiv. $\hat{U}$ \\ \hline 
(000) & $\hat{V}_0$ & $\hat{U}_0$ & (100) & $\hat{V}_0 \hat{V}_1 \hat{V}_2 \hat{V}_5 \hat{V}_6$ & $\hat{U}_4$ \\
(001) & $\hat{V}_0 \hat{V}_4 \hat{V}_7$ & $\hat{U}_1$ & (101) & $\hat{V}_0 \hat{V}_1 \hat{V}_2 \hat{V}_4 \hat{V}_7$ & $\hat{U}_5$ \\
(010) & $\hat{V}_0 \hat{V}_2 \hat{V}_4 \hat{V}_5$ & $\hat{U}_2 $& (110) & $\hat{V}_0 \hat{V}_1 \hat{V}_3 \hat{V}_4 \hat{V}_6  $ & $\hat{U}_6$ \\
(011) & $\hat{V}_0 \hat{V}_2 \hat{V}_3 \hat{V}_6 \hat{V}_7 $ & $\hat{U}_3$ & (111) & $\hat{V}_0 \hat{V}_1 \hat{V}_3 \hat{V}_5 \hat{V}_7$ & $\hat{U}_7$
\end{tabular}
\caption{Operations applied to $\ket{j_k}$ for various control states}
\end{table}
\end{frame}

\begin{frame}
\begin{itemize}
\item The control structure required to apply the appropriate $\hat{U}^{(k)}_u$ to the $k$-th target qubit requires $2^{m+1} -3$ CX gates 
\item As there are $n-m$ target qubits this brings the CX count to $(n-m) (2^{m+1}-3)$ 
\item Note that the $\hat{U}^{(k)}_u$ are not directly implemented but rather are defined as the product of $\hat{V}^{(k)}_q$
\item Since a product of rotation operators corresponds to a sum of rotation angles, this defines a linear system of $2^m$ equations (one for each $\hat{U}^{(k)}_u$) involving $2^m$ variables (the $\hat{V}^{(k)}_q$) and hence the $\hat{V}^{(k)}_q$ can be constructed from the $\hat{U}^{(k)}_u$   
\item Since an $m$-controlled operation requires $m^2$ (or $m$ with ancillae) CX these will be avoided (using single-controlled operations only!) as will have $2^m$ directly ! 
\item Now think about how to deal with controls themselves...
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Comparison}
\begin{itemize}
\item The current implementation uses $n_l \equiv m$ label qubits (with $2^{n_l} =M$) as well as $n_c$ coefficient qubits  
\item The label operation, which initialises the label register into the state $\ket{u}$ if $j \in \mathcal{D}_u$ has a CX cost of 
\begin{equation}
C_\text{Label}(n, n_l) = 2 n_l (n_l -1) + 2^{n_l +1 } (6 n + n_l +1) 
\end{equation}
\item The label gate architecture is proposed in H\"aner 2018 and consists of an incrementing circuit and integer comparator circuits...
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Handling the Controls}
\begin{itemize}
\item Requires a single ancilla 
\item To encode the phase on the $l$th control, apply a CX gate to the ancilla, controlled by $\ket{j_l}$; use the same control structure as before but with the ancilla as target ; at the end of the control circuit apply a SWAP between ancilla and $\ket{j_l}$ ; finally apply a CX on the ancilla, controlled by $\ket{j_l}$ to reset the ancilla to zero 
\item Thus, to encode the phase on each control requires the same control structure as before with an additional 5 CX gate (3 in SWAP)
\item Thus, the $m$ controls require $m (2^{m+2})$ CX giving the total algorithm a CX cost of 
\begin{equation}
(n-m) (2^{m+1} -3) + m 2^{m+2} = 2^{m +1} \left( n + m  \right) - 3 (n-m) = n (2^{m+1} -3) + m (2^{m+1} +3)
\end{equation}
\item Hence, for $n \ll m$ the CX gate cost is $\mathcal{O}(n 2^m)$
\item This is a quadratic speed-up in $n$ as well as a significant reduction in the number of ancillae 
\item Note that cascading the above to all control qubits results in situations where a qubit with non-zero phase acts as a control for a rotation, with the phases of the target and control ambiguously distributed; however, for the present phase encoding only the product of all qubit phase factors is relevant so that this is not an issue  
\end{itemize}

\end{frame}

\begin{frame}
\frametitle{Comments Sarah}
For the other problem, yes this is exactly what I had in mind, this is the right idea. A couple of suggestions:
\begin{itemize}
\item I think that you can get rid of the ancillae entirely, and just condition directly on the first few (log M) qubits.
\item I agree that you should be able to simplify a bit more by thinking about applying the operators recursively.
\item Sadly it will always scale exponentially if we take $M \sim O(2^n)$. It would be helpful to consider breaking the circuit (conceptually, not literally...) into m = log M qubits (which will be the controls) and n-m remaining qubits (the targets). If m $\ll$ n, how does the complexity scale with m and n?
\item Finally, how does the complexity of applying the phase in this way compare to the previous method of calculating the phase in an ancilla register, applying the phase, and then uncomputing the result in the ancilla.
\end{itemize}

\end{frame}



\section{Handover}

\begin{frame}

\frametitle{Handover}

The code, documentation, slides, and poster are all available on GitHub:
\begin{center}
\vspace{0.6cm}
\href{https://github.com/david-f-amorim/PQC_function_evaluation}{\texttt{https://github.com/david-f-amorim/PQC\_function\_evaluation}}
\vspace{0.6cm}
\end{center}

\begin{itemize}
\item The source code is found in the directory \alert{\texttt{pqcprep}} 
\item The slides and poster are found in the directory \alert{\texttt{slides}}
\item The documentation is hosted externally  \href{https://david-f-amorim.github.io/PQC_function_evaluation/pqcprep.html}{\textcolor{purple}{here}}, which is also linked on GitHub
\end{itemize}

\end{frame}

\end{document}